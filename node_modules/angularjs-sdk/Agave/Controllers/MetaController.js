/**
  *AgavePlatformScienceAPILib
  *
  * This file was automatically generated by APIMATIC BETA v2.0 on 10/07/2015
  */

'use strict';
angular.module('AgavePlatformScienceAPILib').factory('MetaController',function($q,Configuration,HttpClient,APIHelper){
    return{
        /**
         * List and/or search metadata.
         * @param {string} q    Required parameter: The query to perform. Traditional MongoDB queries are supported
         * @param {int|null} limit    Optional parameter: The maximum number of results returned from this query
         * @param {int|null} offset    Optional parameter: The number of results skipped in the result set returned from this query
         *
         * @return {promise<array>}
         */
        listMetadata : function(q, limit, offset){
            //Assign default values
            limit = limit || 100;
            offset = offset || 0;

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data";
            
            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true,
                "q" : q,
                "limit" : (null != limit)? limit: 100,
                "offset" : (null != offset)? offset: 0
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "GET",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user does not supply a UUID or supplies an invalid JSON query", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 401) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if the user is not authorized.", errorCode: 401, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified metadata cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Update or Add new Metadata.
         * @param {Metadata} body    Required parameter: The metadata to add.
         *
         * @return {promise<Metadata>}
         */
        addMetadata : function(body){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data";
            
            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "content-type" : "application/json; charset=utf-8",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "POST",
                queryUrl : queryUrl,
                headers: headers,
                body : body
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user supplies an invalid form", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 401) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if the user is not authorized.", errorCode: 401, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Retrieve Metadata.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<Metadata>}
         */
        getMetadata : function(uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "GET",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user does not supply a UUID", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 401) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if the user is not authorized.", errorCode: 401, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified metadata cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Update or Add new Metadata.
         * @param {Metadata} body    Required parameter: The metadata to update.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<Metadata>}
         */
        updateMetadata : function(body, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "content-type" : "application/json; charset=utf-8",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "POST",
                queryUrl : queryUrl,
                headers: headers,
                body : body
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user supplies an invalid form", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 401) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if the user is not authorized.", errorCode: 401, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Remove Metadata from the system.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<void>}
         */
        deleteMetadata : function(uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "DELETE",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user supplies no UUID", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 401) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if the user is not authorized.", errorCode: 401, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Add a new Metadata Schema.
         * @param {MetadataSchema} body    Required parameter: A valid JSON Schema object
         *
         * @return {promise<MetadataSchema>}
         */
        addMetadataSchema : function(body){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas";
            
            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "content-type" : "application/json; charset=utf-8",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "POST",
                queryUrl : queryUrl,
                headers: headers,
                body : body
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user supplies an invalid form or JSON schema", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 401) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if the user is not authorized.", errorCode: 401, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Update an existing Metadata Schema.
         * @param {PermissionModel} body    Required parameter: A valid JSON Schema object
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<MetadataSchema>}
         */
        updateMetadataSchema : function(body, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "content-type" : "application/json; charset=utf-8",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "POST",
                queryUrl : queryUrl,
                headers: headers,
                body : body
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user supplies an invalid form or JSON schema", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 401) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if the user is not authorized.", errorCode: 401, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Remove Metadata Schema from the system.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<void>}
         */
        deleteMetadataSchema : function(uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "DELETE",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user does not supply a Schema UUID", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 401) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if the user is not authorized.", errorCode: 401, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Get the permission ACL for this metadata.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         * @param {int|null} limit    Optional parameter: The maximum number of results returned from this query
         * @param {int|null} offset    Optional parameter: The number of results skipped in the result set returned from this query
         *
         * @return {promise<PermissionModel>}
         */
        listMetadataPermissions : function(uuid, limit, offset){
            //Assign default values
            limit = limit || 100;
            offset = offset || 0;

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}/pems";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true,
                "limit" : (null != limit)? limit: 100,
                "offset" : (null != offset)? offset: 0
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "GET",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a metadata UUID is not supplied or is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified metadata.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified metadata cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Add a user permission for the given metadata.
         * @param {PermissionModel} body    Required parameter: The metadata permission to update.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<PermissionModel>}
         */
        addMetadataPermission : function(body, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}/pems";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "content-type" : "application/json; charset=utf-8",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "POST",
                queryUrl : queryUrl,
                headers: headers,
                body : body
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a valid metadata UUID is not supplied or if the form is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified metadata.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified user cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Deletes all permissions on the given metadata.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<void>}
         */
        deleteClearMetadataPermissions : function(uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}/pems";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "DELETE",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a metadata UUID is not supplied or is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified metadata.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Get the user permission for this metadata.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<PermissionModel>}
         */
        getMetadataPermission : function(username, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}/pems/{username}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "username" : username,
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "GET",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a metadata UUID is not supplied or is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified metadata.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified metadata cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Update a user's permission for the given metadata.
         * @param {PermissionModel} body    Required parameter: The metadata permission to update.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<PermissionModel>}
         */
        updateMetadataPermission : function(body, username, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}/pems/{username}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "username" : username,
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "content-type" : "application/json; charset=utf-8",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "POST",
                queryUrl : queryUrl,
                headers: headers,
                body : body
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a valid metadata UUID is not supplied or if the form is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified metadata.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified user cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Removes user permissions for a user on a given metadata resource.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<void>}
         */
        deleteMetadataPermission : function(username, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/data/{uuid}/pems/{username}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "username" : username,
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "DELETE",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a metadata UUID is not supplied or is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified metadata.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Get the permission for this schema.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         * @param {int|null} limit    Optional parameter: The maximum number of results returned from this query
         * @param {int|null} offset    Optional parameter: The number of results skipped in the result set returned from this query
         *
         * @return {promise<array>}
         */
        listMetadataSchemaPermissions : function(uuid, limit, offset){
            //Assign default values
            limit = limit || 100;
            offset = offset || 0;

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}/pems";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true,
                "limit" : (null != limit)? limit: 100,
                "offset" : (null != offset)? offset: 0
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "GET",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a schema UUID is not supplied or is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified schema.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified schema cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Add a user's permission for the given schema.
         * @param {PermissionModel} body    Required parameter: The schema permission to update.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<PermissionModel>}
         */
        addMetadataSchemaPermission : function(body, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}/pems";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "content-type" : "application/json; charset=utf-8",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "POST",
                queryUrl : queryUrl,
                headers: headers,
                body : body
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a valid schema UUID is not supplied or if the form is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified schema.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified user cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Deletes all permissions on the given schema.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<void>}
         */
        deleteClearMetadataSchemaPermissions : function(uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}/pems";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "DELETE",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a schema UUID is not supplied or is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified schema.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Get the user permission for this schema.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<PermissionModel>}
         */
        getMetadataSchemaPermission : function(username, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}/pems/{username}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "username" : username,
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "GET",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a schema UUID is not supplied or is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified schema.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified schema cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Add or update a user's permission for the given metadata schema.
         * @param {PermissionModel} body    Required parameter: The schema permission to update.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<PermissionModel>}
         */
        updateMetadataSchemaPermission : function(body, username, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}/pems/{username}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "username" : username,
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "content-type" : "application/json; charset=utf-8",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "POST",
                queryUrl : queryUrl,
                headers: headers,
                body : body
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a valid schema UUID is not supplied or if the form is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified schema.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 404) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The specified user cannot be found", errorCode: 404, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Deletes all metadata schema permissions on the given metadata.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<void>}
         */
        deleteSchemaPermission : function(username, uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}/pems/{username}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "username" : username,
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "DELETE",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a schema UUID is not supplied or is invalid.", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user or the user is not authorized to access the specified schema.", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the metadata schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * Retrieve Metadata Schemata.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<MetadataSchema>}
         */
        getMetadataSchema : function(uuid){

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas/{uuid}";
            
            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                "uuid" : uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "GET",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user does not supply a Schema UUID", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        },
        /**
         * List and query Metadata Schemata.
         * @param {string} q    Required parameter: A valid query object defining the search parameters.
         * @param {int|null} limit    Optional parameter: The maximum number of results returned from this query
         * @param {int|null} offset    Optional parameter: The number of results skipped in the result set returned from this query
         *
         * @return {promise<array>}
         */
        listMetadataSchema : function(q, limit, offset){
            //Assign default values
            limit = limit || 100;
            offset = offset || 0;

            //prepare query string for API call
            var baseUri = Configuration.BASEURI
            var queryBuilder = baseUri + "/meta/v2/schemas";
            
            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                "naked" : true,
                "q" : q,
                "limit" : (null != limit)? limit: 100,
                "offset" : (null != offset)? offset: 0
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);
            
            //prepare headers
            var headers = {
                "accept" : "application/json",
                "Authorization" : "Bearer " + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method : "GET",
                queryUrl : queryUrl,
                headers: headers,
            };
            
            var response = HttpClient(config);
                    
            //Create promise to return
            var deffered= $q.defer();
                    
            //process response
            response.then(function(result){
                deffered.resolve(result.body);
            },function(result){
                //Error handling for custom HTTP status codes
                if (code == 400) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Raised if a user does not supply a Schema UUID", errorCode: 400, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 403) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "Failed to authenticate the user", errorCode: 403, errorResponse: result.message},result.getContext()));
                    return;
                } else if (code == 500) {
                    deffered.reject(APIHelper.appendContext({errorMessage: "The service was unable to query the schema database", errorCode: 500, errorResponse: result.message},result.getContext()));
                    return;
                }

                deffered.reject(APIHelper.appendContext({errorMessage:"HTTP Response Not OK", errorCode: result.code, errorResponse: result.message},result.getContext()));
            });
            
            return deffered.promise;
        }
    }
});