/**
 *AgavePlatformScienceAPILib
 *
 * This file was automatically generated by APIMATIC BETA v2.0 on 10/07/2015
 */

'use strict';
angular.module('AgavePlatformScienceAPILib').factory('MetaController', ['$q', 'Configuration', 'HttpClient', 'APIHelper', function ($q, Configuration, HttpClient, APIHelper) {
    return {
        /**
         * List and/or search metadata.
         * @param {string} q    Required parameter: The query to perform. Traditional MongoDB queries are supported
         * @param {int|null} limit    Optional parameter: The maximum number of results returned from this query
         * @param {int|null} offset    Optional parameter: The number of results skipped in the result set returned from this query
         *
         * @return {promise<array>}
         */
        listMetadata: function (q, limit, offset) {
            //Assign default values
            limit = limit || 100;
            offset = offset || 0;

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data';

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                'q': q,
                'limit': (null !== limit) ? limit : 100,
                'offset': (null !== offset) ? offset : 0
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'GET',
                queryUrl: queryUrl,
                headers: headers,
                cache: false
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Update or Add new Metadata.
         * @param {Metadata} body    Required parameter: The metadata to add.
         *
         * @return {promise<Metadata>}
         */
        addMetadata: function (body) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data';

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'content-type': 'application/json; charset=utf-8',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'POST',
                queryUrl: queryUrl,
                headers: headers,
                body: body
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Retrieve Metadata.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<Metadata>}
         */
        getMetadata: function (uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'GET',
                queryUrl: queryUrl,
                headers: headers,
				cache: false
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Update or Add new Metadata.
         * @param {Metadata} body    Required parameter: The metadata to update.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<Metadata>}
         */
        updateMetadata: function (body, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'content-type': 'application/json; charset=utf-8',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'POST',
                queryUrl: queryUrl,
                headers: headers,
                body: body
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Remove Metadata from the system.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<void>}
         */
        deleteMetadata: function (uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'DELETE',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Add a new Metadata Schema.
         * @param {MetadataSchema} body    Required parameter: A valid JSON Schema object
         *
         * @return {promise<MetadataSchema>}
         */
        addMetadataSchema: function (body) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas';

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'content-type': 'application/json; charset=utf-8',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'POST',
                queryUrl: queryUrl,
                headers: headers,
                body: body
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Update an existing Metadata Schema.
         * @param {PermissionModel} body    Required parameter: A valid JSON Schema object
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<MetadataSchema>}
         */
        updateMetadataSchema: function (body, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'content-type': 'application/json; charset=utf-8',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'POST',
                queryUrl: queryUrl,
                headers: headers,
                body: body
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Remove Metadata Schema from the system.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<void>}
         */
        deleteMetadataSchema: function (uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'DELETE',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Get the permission ACL for this metadata.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         * @param {int|null} limit    Optional parameter: The maximum number of results returned from this query
         * @param {int|null} offset    Optional parameter: The number of results skipped in the result set returned from this query
         *
         * @return {promise<PermissionModel>}
         */
        listMetadataPermissions: function (uuid, limit, offset) {
            //Assign default values
            limit = limit || 100;
            offset = offset || 0;

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}/pems';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                'limit': (null !== limit) ? limit : 100,
                'offset': (null !== offset) ? offset : 0
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'GET',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Add a user permission for the given metadata.
         * @param {PermissionModel} body    Required parameter: The metadata permission to update.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<PermissionModel>}
         */
        addMetadataPermission: function (body, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}/pems';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'content-type': 'application/json; charset=utf-8',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'POST',
                queryUrl: queryUrl,
                headers: headers,
                body: body
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Deletes all permissions on the given metadata.
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<void>}
         */
        deleteClearMetadataPermissions: function (uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}/pems';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'DELETE',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Get the user permission for this metadata.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<PermissionModel>}
         */
        getMetadataPermission: function (username, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}/pems/{username}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'username': username,
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'GET',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Update a user's permission for the given metadata.
         * @param {PermissionModel} body    Required parameter: The metadata permission to update.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<PermissionModel>}
         */
        updateMetadataPermission: function (body, username, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}/pems/{username}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'username': username,
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'content-type': 'application/json; charset=utf-8',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'POST',
                queryUrl: queryUrl,
                headers: headers,
                body: body
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Removes user permissions for a user on a given metadata resource.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata item
         *
         * @return {promise<void>}
         */
        deleteMetadataPermission: function (username, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/data/{uuid}/pems/{username}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'username': username,
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'DELETE',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Get the permission for this schema.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         * @param {int|null} limit    Optional parameter: The maximum number of results returned from this query
         * @param {int|null} offset    Optional parameter: The number of results skipped in the result set returned from this query
         *
         * @return {promise<array>}
         */
        listMetadataSchemaPermissions: function (uuid, limit, offset) {
            //Assign default values
            limit = limit || 100;
            offset = offset || 0;

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}/pems';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                'limit': (null !== limit) ? limit : 100,
                'offset': (null !== offset) ? offset : 0
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'GET',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Add a user's permission for the given schema.
         * @param {PermissionModel} body    Required parameter: The schema permission to update.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<PermissionModel>}
         */
        addMetadataSchemaPermission: function (body, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}/pems';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'content-type': 'application/json; charset=utf-8',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'POST',
                queryUrl: queryUrl,
                headers: headers,
                body: body
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Deletes all permissions on the given schema.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<void>}
         */
        deleteClearMetadataSchemaPermissions: function (uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}/pems';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'DELETE',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Get the user permission for this schema.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<PermissionModel>}
         */
        getMetadataSchemaPermission: function (username, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}/pems/{username}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'username': username,
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'GET',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Add or update a user's permission for the given metadata schema.
         * @param {PermissionModel} body    Required parameter: The schema permission to update.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<PermissionModel>}
         */
        updateMetadataSchemaPermission: function (body, username, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}/pems/{username}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'username': username,
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'content-type': 'application/json; charset=utf-8',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //Remove null values
            APIHelper.cleanObject(body);

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'POST',
                queryUrl: queryUrl,
                headers: headers,
                body: body
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Deletes all metadata schema permissions on the given metadata.
         * @param {string} username    Required parameter: The username of the permission owner
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<void>}
         */
        deleteSchemaPermission: function (username, uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}/pems/{username}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'username': username,
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'DELETE',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * Retrieve Metadata Schemata.
         * @param {string} uuid    Required parameter: The uuid of the metadata schema item
         *
         * @return {promise<MetadataSchema>}
         */
        getMetadataSchema: function (uuid) {

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas/{uuid}';

            //Process template parameters
            queryBuilder = APIHelper.appendUrlWithTemplateParameters(queryBuilder, {
                'uuid': uuid
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'GET',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        },
        /**
         * List and query Metadata Schemata.
         * @param {string} q    Required parameter: A valid query object defining the search parameters.
         * @param {int|null} limit    Optional parameter: The maximum number of results returned from this query
         * @param {int|null} offset    Optional parameter: The number of results skipped in the result set returned from this query
         *
         * @return {promise<array>}
         */
        listMetadataSchema: function (q, limit, offset) {
            //Assign default values
            limit = limit || 100;
            offset = offset || 0;

            //prepare query string for API call
            var baseUri = Configuration.BASEURI;
            var queryBuilder = baseUri + '/meta/v2/schemas';

            //Process query parameters
            queryBuilder = APIHelper.appendUrlWithQueryParameters(queryBuilder, {
                'q': q,
                'limit': (null !== limit) ? limit : 100,
                'offset': (null !== offset) ? offset : 0
            });

            //validate and preprocess url
            var queryUrl = APIHelper.cleanUrl(queryBuilder);

            //prepare headers
            var headers = {
                'accept': 'application/json',
                'Authorization': 'Bearer ' + Configuration.oAuthAccessToken
            };

            //prepare and invoke the API call request to fetch the response
            var config = {
                method: 'GET',
                queryUrl: queryUrl,
                headers: headers,
            };

            var response = new HttpClient(config);

            //Create promise to return
            var deferred = $q.defer();

            //process response
            response.then(function (result) {
                deferred.resolve(result.body);
            }, function (result) {
                deferred.reject(APIHelper.appendContext({
                    errorMessage: 'HTTP Response Not OK',
                    errorCode: result.code,
                    errorResponse: result.message
                }, result.getContext()));
            });

            return deferred.promise;
        }
    };
}]);
